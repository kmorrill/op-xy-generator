<!DOCTYPE html>
<html>
  <head>
    <title>OP-XY MIDI Control</title>
    <style>
      .patch-controls {
        margin: 20px 0;
        border-collapse: collapse;
      }

      .patch-controls td {
        padding: 8px;
        vertical-align: middle;
      }

      .patch-controls td:first-child {
        width: 120px;
      }

      .patch-controls input[type="range"] {
        width: 200px;
      }

      .patch-controls select {
        width: 200px;
        padding: 4px;
      }

      .patch-controls span {
        min-width: 40px;
        display: inline-block;
      }
    </style>
    <script src="patch_generator_opxy.js" defer></script>
    <script src="patch_generator_gen.js" defer></script>
  </head>
  <body>
    <div id="status"></div>

    <table class="patch-controls">
      <tr>
        <td>Patch Type:</td>
        <td colspan="2">
          <select id="patchType">
            <option value="lead">Lead</option>
            <option value="bass">Bass</option>
            <option value="pad">Pad</option>
            <option value="pluck">Pluck</option>
            <option value="fx">FX</option>
          </select>
        </td>
        <td>
          <span
            >Defines the overall role of the sound, such as melodic leads,
            basslines, atmospheric pads, sharp plucks, or sound effects.</span
          >
        </td>
      </tr>
      <tr>
        <td>Synth Engine:</td>
        <td colspan="2">
          <select id="engineType">
            <option value="random">Random</option>
            <option value="Axis">Axis</option>
            <option value="Dissolve">Dissolve</option>
            <option value="Eano">Eano</option>
            <option value="HardSync">Hard Sync</option>
            <option value="Organ">Organ</option>
            <option value="Prism">Prism</option>
            <option value="Simple">Simple</option>
            <option value="Wavetable">Wavetable</option>
          </select>
        </td>
        <td>
          <span
            >Determines the type of synthesizer engine to use, affecting the
            timbre and characteristics of the sound.</span
          >
        </td>
      </tr>
      <tr>
        <td>Brightness:</td>
        <td>
          <input type="range" id="brightness" min="0" max="100" value="50" />
        </td>
        <td><span id="brightnessValue">0.5</span></td>
        <td>
          <span
            >Controls the tonal brightness of the sound, ranging from dark and
            muted to bright and sharp. A darker sound emphasizes lower
            frequencies and can feel warm or subdued, while a brighter sound
            emphasizes higher frequencies, creating clarity and sharpness.</span
          >
        </td>
      </tr>
      <tr>
        <td>Movement:</td>
        <td>
          <input type="range" id="movement" min="0" max="100" value="50" />
        </td>
        <td><span id="movementValue">0.5</span></td>
        <td>
          <span
            >Adjusts the dynamic modulation of the sound, creating a sense of
            motion or stability.</span
          >
        </td>
      </tr>
      <tr>
        <td>Complexity:</td>
        <td>
          <input type="range" id="complexity" min="0" max="100" value="50" />
        </td>
        <td><span id="complexityValue">0.5</span></td>
        <td>
          <span
            >Determines the intricacy of the sound, influencing its layering and
            harmonic depth. Higher complexity can introduce richer harmonics,
            more active modulation, or additional notes, while lower complexity
            keeps the sound simpler and cleaner.</span
          >
        </td>
      </tr>
      <tr>
        <td>Character:</td>
        <td>
          <input type="range" id="character" min="0" max="100" value="50" />
        </td>
        <td><span id="characterValue">0.5</span></td>
        <td>
          <span
            >Defines the tonal personality of the sound, such as smooth, gritty,
            or textured. higher character values might increase the amount of
            grit in a bassline, add shimmering harmonics to a lead, or emphasize
            modulated textures in a pad. Lower character values could smooth out
            the sound, making it more neutral or clean. It also influences
            secondary effects, like the intensity of modulation or the
            responsiveness of filters and envelopes.</span
          >
        </td>
      </tr>
      <tr>
        <td>Resonance:</td>
        <td>
          <input type="range" id="resonance" min="0" max="100" value="50" />
        </td>
        <td><span id="resonanceValue">0.5</span></td>
        <td>
          <span
            >Emphasizes frequencies around the filter cutoff point, affecting
            the sharpness of the sound. High resonance can also create a
            distinct ringing or whistling effect at the cutoff frequency, add a
            sense of movement as the filter sweeps, and even push the filter
            into self-oscillation for unique tonal effects.</span
          >
        </td>
      </tr>
      <tr>
        <td>Spatial Width:</td>
        <td>
          <input type="range" id="spatialWidth" min="0" max="100" value="50" />
        </td>
        <td><span id="spatialWidthValue">0.5</span></td>
        <td>
          <span
            >Controls the stereo width of the sound, from mono to wide and
            spacious.</span
          >
        </td>
      </tr>
    </table>

    <script>
      // Add to the HTML

      document.addEventListener("DOMContentLoaded", () => {
        const generateButton = document.createElement("button");
        generateButton.textContent = "Generate Random Patch";

        document.body.appendChild(generateButton);

        // Create and initialize the OPXY instance
        const opxy = new OPXY();

        generateButton.onclick = () => {
          const getSliderValue = (id) =>
            document.getElementById(id).value / 100;

          // Turn off any currently running automations
          opxy.tracks.forEach((track) => {
            track.automations.forEach((automations, parameterName) => {
              automations.forEach((automation) => {
                automation.endValue = automation.startValue;
                automation.duration = 0;
              });
            });
            track.patterns.forEach((pattern) => {
              pattern.notes.forEach((note) => {
                note.velocity = 0; // Turn off playing sequences
              });
            });
          });

          opxy.generateAndApplyPatch({
            patchType: document.getElementById("patchType").value,
            engineSelection: document.getElementById("engineType").value,
            brightness: getSliderValue("brightness"),
            movement: getSliderValue("movement"),
            complexity: getSliderValue("complexity"),
            character: getSliderValue("character"),
            resonance: getSliderValue("resonance"),
            spatialWidth: getSliderValue("spatialWidth"),
          });
        };

        opxy.initialize().then(() => {
          console.log("OPXY initialized and ready");
        });

        const validateMIDICCs = () => {
          // Check for any undefined mappings
          Object.entries(PARAMETER_DEFINITIONS).forEach(([key, value]) => {
            if (value.cc === undefined) {
              console.warn(`Missing CC number for parameter: ${key}`);
            }
          });
        };

        validateMIDICCs();

        // Log the initial state of all tracks
        opxy.tracks.forEach((track, trackName) => {
          console.log(`Track ${trackName} initial state:`, {
            channel: track.channel,
            parameters: track.parameters,
            automations: Array.from(track.automations.entries()),
          });
        });
      });
    </script>
  </body>
</html>
